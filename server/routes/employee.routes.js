import express from 'express';
import bcrypt from 'bcrypt';
import db from '../config/db.js';
import { requireEmployeeAuth, makeEmployeeToken } from '../middleware/auth.js';

const router = express.Router();

// Get all employees - EXCLUDE password
router.get('/', async (req, res) => {
  const sql = `SELECT employee_id, first_name, last_name, gender, email,
               job_title, phone, ssn, salary, hire_date, terminate_date
               FROM employee`;
  db.query(sql, (err, results) => {
    if (err) {
      return res.status(500).json({
        message: 'Error fetching employees',
        error: err.message
      });
    }
    res.json({ data: results });
  });
});

// Get maintenance employees
router.get('/maintenance', async (req, res) => {
  const sql = `SELECT employee_id, first_name, last_name, gender, email,
               job_title, phone, hire_date
               FROM employee
               WHERE deleted_at IS NULL AND terminate_date IS NULL
               AND job_title ='Mechanical Employee'`;
  db.query(sql, (err, results) => {
    if (err) {
      return res.status(500).json({
        message: 'Error fetching employees',
        error: err.message
      });
    }
    res.json({ data: results });
  });
});

// Add new employee
router.post('/add', async (req, res) => {
  const { first_name, last_name, job_title, gender, phone, ssn, hire_date, salary } = req.body;

  // Generate temporary email (will be updated after we get employee_id)
  const tempEmail = `temp_${Date.now()}@velocityvalley.com`;

  const sql = `INSERT INTO employee(first_name, last_name, job_title, gender, phone, ssn, hire_date, salary, email )
              VALUES (?,?,?,?,?,?,?,?,?)`;
  db.query(sql, [first_name, last_name, job_title, gender, phone, ssn, hire_date, salary, tempEmail], (err, result) => {
    if (err) {
      console.error('Error adding employee:', err);
      return res.status(500).json({
        message: 'Error adding employee',
        error: err.message
      })
    }

    // Generate the proper email using employee_id
    const employeeId = result.insertId;
    const properEmail = `${first_name.toLowerCase().trim()}.${last_name.toLowerCase().trim()}.${employeeId}@velocityvalley.com`;

    // Update the email with the proper format
    const updateEmailSql = `UPDATE employee SET email = ? WHERE employee_id = ?`;
    db.query(updateEmailSql, [properEmail, employeeId], (updateErr) => {
      if (updateErr) {
        console.error('Error updating email:', updateErr);
        return res.status(500).json({
          message: 'Employee added but failed to update email',
          error: updateErr.message
        });
      }

      // Fetch the employee's password (generated by BEFORE INSERT trigger)
      const fetchSql = `SELECT email, password FROM employee WHERE employee_id = ?`;
      db.query(fetchSql, [employeeId], (fetchErr, fetchResult) => {
        if (fetchErr) {
          return res.status(500).json({
            message: 'Employee added but failed to retrieve credentials',
            error: fetchErr.message
          });
        }

        const employeeData = fetchResult[0];
        res.status(201).json({
          message: 'Employee added successfully',
          employeeId: employeeId,
          email: employeeData.email,
          temporaryPassword: employeeData.password
        });
      });
    });
  })
});

// Update an employee
router.put('/:id', async (req, res) => {
  const {
    first_name, last_name, job_title, gender,
    email, phone, ssn, hire_date, terminate_date, salary
  } = req.body;
  const id = req.params.id;

  // Convert dates to YYYY-MM-DD
  const hireDate = hire_date ? hire_date.slice(0, 10) : null;
  const terminateDate = terminate_date ? terminate_date.slice(0, 10) : null;

  const sql = `
    UPDATE employee
    SET
      first_name = ?,
      last_name = ?,
      job_title = ?,
      gender = ?,
      email = ?,
      phone = ?,
      ssn = ?,
      hire_date = ?,
      terminate_date = ?,
      salary = ?
    WHERE employee_id = ?;
  `;
  db.query(sql, [
    first_name, last_name, job_title, gender,
    email, phone, ssn, hireDate, terminateDate, salary, id
  ], (err, result) => {
    if (err) {
      console.error("DB error:", err);
      return res.status(500).json({
        message: 'Error updating employee',
        error: err.message
      });
    }
    res.json({ message: "Employee updated successfully", data: result });
  });
});

// Terminate an employee
router.delete('/:id', async (req, res) => {
  const id = req.params.id;
  const sql = `UPDATE employee
               SET terminate_date = CURDATE()
               WHERE employee_id = ?;`;
  db.query(sql, [id], (err, result) => {
    if (err) {
      return res.status(500).json({
        message: 'Error terminating employee',
        error: err.message
      });
    }
    res.json({ message: "Employee terminated successfully", data: result });
  });
});

// Change employee password (first-time login or password reset)
router.post('/change-password', requireEmployeeAuth, async (req, res) => {
  const { new_password } = req.body;
  const employee_id = req.employee_id; // From JWT token

  if (!new_password) {
    return res.status(400).json({
      message: 'New password is required'
    });
  }

  // Validate password strength
  if (new_password.length < 8) {
    return res.status(400).json({
      message: 'Password must be at least 8 characters long'
    });
  }

  try {
    // Hash the new password
    const hashedPassword = await bcrypt.hash(new_password, 10);

    // Update the password and set password_changed to TRUE
    const sql = `UPDATE employee
                 SET password = ?, password_changed = TRUE
                 WHERE employee_id = ? AND deleted_at IS NULL AND terminate_date IS NULL`;

    const result = await new Promise((resolve, reject) => {
      db.query(sql, [hashedPassword, employee_id], (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });

    if (result.affectedRows === 0) {
      return res.status(404).json({
        message: 'Employee not found or already terminated'
      });
    }

    // Fetch updated employee data to generate new token
    const fetchSql = `SELECT employee_id, email, first_name, last_name, job_title, phone, hire_date, gender, password_changed
                      FROM employee
                      WHERE employee_id = ?`;

    const employeeRows = await new Promise((resolve, reject) => {
      db.query(fetchSql, [employee_id], (err, results) => {
        if (err) reject(err);
        else resolve(results);
      });
    });

    if (employeeRows.length === 0) {
      return res.status(404).json({
        message: 'Employee not found'
      });
    }

    const employee = employeeRows[0];

    // Generate new token with updated employee data
    const newToken = makeEmployeeToken(employee);

    res.json({
      message: 'Password changed successfully',
      token: newToken,
      data: {
        employee_id: employee.employee_id,
        email: employee.email,
        first_name: employee.first_name,
        last_name: employee.last_name,
        job_title: employee.job_title,
        phone: employee.phone,
        hire_date: employee.hire_date,
        gender: employee.gender,
        password_changed: employee.password_changed,
        is_employee: true
      }
    });

  } catch (err) {
    console.error('Error changing password:', err);
    return res.status(500).json({
      message: 'Error changing password',
      error: err.message
    });
  }
});

// Change employee password with current password verification (for profile page)
router.post('/change-password-verified', requireEmployeeAuth, async (req, res) => {
  const { current_password, new_password } = req.body;
  const employee_id = req.employee_id; // From JWT token

  if (!current_password || !new_password) {
    return res.status(400).json({
      message: 'Current password and new password are required'
    });
  }

  // Validate password strength
  if (new_password.length < 8) {
    return res.status(400).json({
      message: 'Password must be at least 8 characters long'
    });
  }

  try {
    // Fetch current employee data to verify password
    const fetchSql = `SELECT employee_id, email, password, first_name, last_name, job_title, phone, hire_date, gender, password_changed
                      FROM employee
                      WHERE employee_id = ? AND deleted_at IS NULL AND terminate_date IS NULL`;

    const employeeRows = await new Promise((resolve, reject) => {
      db.query(fetchSql, [employee_id], (err, results) => {
        if (err) reject(err);
        else resolve(results);
      });
    });

    if (employeeRows.length === 0) {
      return res.status(404).json({
        message: 'Employee not found or already terminated'
      });
    }

    const employee = employeeRows[0];

    // Verify current password
    const isPasswordValid = await bcrypt.compare(current_password, employee.password);
    if (!isPasswordValid) {
      return res.status(401).json({
        message: 'Current password is incorrect'
      });
    }

    // Check if new password is same as current
    const isSamePassword = await bcrypt.compare(new_password, employee.password);
    if (isSamePassword) {
      return res.status(400).json({
        message: 'New password must be different from current password'
      });
    }

    // Hash the new password
    const hashedPassword = await bcrypt.hash(new_password, 10);

    // Update the password
    const updateSql = `UPDATE employee
                       SET password = ?, password_changed = TRUE
                       WHERE employee_id = ?`;

    await new Promise((resolve, reject) => {
      db.query(updateSql, [hashedPassword, employee_id], (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });

    // Generate new token with updated employee data
    const newToken = makeEmployeeToken({
      employee_id: employee.employee_id,
      email: employee.email,
      first_name: employee.first_name,
      last_name: employee.last_name,
      job_title: employee.job_title,
      phone: employee.phone,
      hire_date: employee.hire_date,
      gender: employee.gender,
      password_changed: true
    });

    res.json({
      message: 'Password changed successfully',
      token: newToken,
      data: {
        employee_id: employee.employee_id,
        email: employee.email,
        first_name: employee.first_name,
        last_name: employee.last_name,
        job_title: employee.job_title,
        phone: employee.phone,
        hire_date: employee.hire_date,
        gender: employee.gender,
        password_changed: true,
        is_employee: true
      }
    });

  } catch (err) {
    console.error('Error changing password:', err);
    return res.status(500).json({
      message: 'Error changing password',
      error: err.message
    });
  }
});

// Revoke termination - set terminate_date to NULL
router.patch('/:id/revoke-termination', async (req, res) => {
  const id = req.params.id;
  const sql = `UPDATE employee
               SET terminate_date = NULL
               WHERE employee_id = ?`;
  db.query(sql, [id], (err, result) => {
    if (err) {
      return res.status(500).json({
        message: 'Error revoking termination',
        error: err.message
      });
    }
    if (result.affectedRows === 0) {
      return res.status(404).json({
        message: 'Employee not found'
      });
    }
    res.json({ message: "Employee termination revoked successfully", data: result });
  });
});

// Permanently delete employee - soft delete by setting deleted_at
router.delete('/:id/permanent', async (req, res) => {
  const id = req.params.id;
  const sql = `UPDATE employee
               SET deleted_at = NOW()
               WHERE employee_id = ?`;
  db.query(sql, [id], (err, result) => {
    if (err) {
      return res.status(500).json({
        message: 'Error deleting employee',
        error: err.message
      });
    }
    if (result.affectedRows === 0) {
      return res.status(404).json({
        message: 'Employee not found'
      });
    }
    res.json({ message: "Employee deleted permanently", data: result });
  });
});

// Reset employee password (admin function) - generates new random password and sets password_changed to FALSE
router.patch('/:id/reset-password', async (req, res) => {
  const id = req.params.id;

  try {
    // Generate a random 12-character password
    const randomPassword = Math.random().toString(36).slice(-12) + Math.random().toString(36).slice(-12);
    const tempPassword = randomPassword.slice(0, 12);

    // Hash the password
    const hashedPassword = await bcrypt.hash(tempPassword, 10);

    // Update employee password and set password_changed to FALSE
    const sql = `UPDATE employee
                 SET password = ?, password_changed = FALSE
                 WHERE employee_id = ?`;

    db.query(sql, [hashedPassword, id], (err, result) => {
      if (err) {
        return res.status(500).json({
          message: 'Error resetting password',
          error: err.message
        });
      }

      if (result.affectedRows === 0) {
        return res.status(404).json({
          message: 'Employee not found'
        });
      }

      // Return the temporary password (only shown once)
      res.json({
        message: 'Password reset successfully',
        temporaryPassword: tempPassword,
        data: result
      });
    });
  } catch (err) {
    console.error('Error resetting password:', err);
    return res.status(500).json({
      message: 'Error resetting password',
      error: err.message
    });
  }
});

export default router;
